"""
Harvard IACS Masters Thesis
candidate_elements.py: 
Generate candidate orbital elements for asteroid search

Michael S. Emanuel
Wed Mar 25 09:55 2020
"""

# Core
import numpy as np
import pandas as pd

# Astronomy
import rebound


# Local
from asteroid_element import load_ast_elt
from planets import make_sim_planets
from astro_utils import mjd_to_datetime, deg2dist, dist2deg

# ********************************************************************************************************************* 
# DataFrame of asteroid snapshots
ast_elt = load_ast_elt()

# ********************************************************************************************************************* 
# Default data type
dtype = np.float64

# ********************************************************************************************************************* 
# Convert between different representations for orbital elements: Numpy table, dictionary and DataFrame
# ********************************************************************************************************************* 

# ********************************************************************************************************************* 
def elts_np2dict(elts_np):
    """Convert an Nx7 array of orbital elements into a dict"""
    # Dictionary
    elts_dict = {
        'a': elts_np[:,0],
        'e': elts_np[:,1],
        'inc': elts_np[:,2],
        'Omega': elts_np[:,3],
        'omega': elts_np[:,4],
        'f': elts_np[:,5],
        'epoch': elts_np[:,6],
    }
    return elts_dict

# ********************************************************************************************************************* 
def elts_np2df(elts_np):
    """Convert an Nx7 array of orbital elements into a DataFrame"""
    # Dictionary
    elts_dict = elts_np2dict(elts_np=elts_np)
    # Return a DataFrame
    return pd.DataFrame(elts_dict)

# ********************************************************************************************************************* 
def elts_df2dict(elts_df):
    """Convert a DataFrame of orbital elements into a dict (built-in Dataframe.to_dict() method fails)"""
    # Columns in the elements DataFrame
    cols_elt = ['a', 'e', 'inc', 'Omega', 'omega', 'f', 'epoch']
    # Return a dict
    return {col: elts_df[col] for col in cols_elt}

# ********************************************************************************************************************* 
# Generate candidate elements from known asteroids (including perturbations)
# ********************************************************************************************************************* 

# ********************************************************************************************************************* 
def asteroid_elts(ast_nums: np.ndarray, dtype = dtype) -> pd.DataFrame:
    """
    Return a batch of orbital elements as a DataFrame
    INPUTS:
        ast_nums: Numpy array of asteroid numbers to include in batch
        score_by_elt: DataFrame generated by ztf_score_by_element in ztf_element.py
        R_deg:    Initial value of resolution parameter (in degrees) in mixture model
        dtype:    Data type for the DataFrame.
    OUTPUTS:
        elts:     DataFrame with columns for a, e, inc, Omega, omega, f, epoch.
                  Also includes h and R for mixture model
    """
    # The orbital elements and epoch
    a = ast_elt.a[ast_nums].values.astype(dtype)
    e = ast_elt.e[ast_nums].values.astype(dtype)
    inc = ast_elt.inc[ast_nums].values.astype(dtype)
    Omega = ast_elt.Omega[ast_nums].values.astype(dtype)
    omega = ast_elt.omega[ast_nums].values.astype(dtype)
    f = ast_elt.f[ast_nums].values.astype(dtype)
    epoch = ast_elt.epoch[ast_nums].to_numpy().astype(dtype)
    
    # Wrap into dictionary
    elts_dict = {
        # 'asteroid_num': ast_nums,
        'element_id': ast_nums,
        'a': a,
        'e': e,
        'inc': inc,
        'Omega': Omega,
        'omega': omega,
        'f': f,
        'epoch': epoch
    }

    # Convert dict to DataFrame
    elts = pd.DataFrame(elts_dict)

    return elts

# ********************************************************************************************************************* 
def perturb_elts(elts: pd.DataFrame, 
                 sigma_a=0.00, sigma_e=0.00, sigma_inc_deg=0.0,
                 sigma_f_deg=1.0, sigma_Omega_deg=0.0, sigma_omega_deg=0.0,
                 mask_pert=None, random_seed: int = 42):
    """Apply perturbations to orbital elements"""
    # Copy the elements; overwrite the original reference to prevent accidentally changing them
    # This can happen due to separate handles to the same numpy array! Caused an obscure bug.
    elts = elts.copy()

    # Default for mask_pert is all elements
    if mask_pert is None:
        mask_pert = np.ones_like(elts['a'], dtype=bool)

    # Number of elements to perturb
    num_shift = np.sum(mask_pert)

    # Set random seed
    np.random.seed(seed=random_seed)

    # Apply shift log(a)
    log_a = np.log(elts['a'])
    log_a[mask_pert] += np.random.normal(scale=sigma_a, size=num_shift)
    elts['a'] = np.exp(log_a)
    
    # Apply shift to log(e)
    log_e = np.log(elts['e'])
    log_e[mask_pert] += np.random.normal(scale=sigma_e, size=num_shift)
    elts['e'] = np.exp(log_e)
    
    # Apply shift directly to inclination inc
    inc = elts['inc'].values
    sigma_inc = np.deg2rad(sigma_inc_deg)
    inc[mask_pert] += np.random.normal(scale=sigma_inc, size=num_shift)
    elts['inc'] = inc
    
    # Apply shift directly to true anomaly f
    f = elts['f'].values
    sigma_f = np.deg2rad(sigma_f_deg)
    f[mask_pert] += np.random.normal(scale=sigma_f, size=num_shift)
    elts['f'] = f
    
    # Apply shift directly to Omega
    Omega = elts['Omega'].values
    sigma_Omega = np.deg2rad(sigma_Omega_deg)
    Omega[mask_pert] += np.random.normal(scale=sigma_Omega, size=num_shift)
    elts['Omega'] = Omega

    # Apply shift directly to omega
    omega = elts['omega'].values
    sigma_omega = np.deg2rad(sigma_omega_deg)
    omega[mask_pert] += np.random.normal(scale=sigma_omega, size=num_shift)
    elts['omega'] = omega

    return elts

# ********************************************************************************************************************* 
# Generate candidate elements by randomly sampling elements of known asteroids
# ********************************************************************************************************************* 

# ********************************************************************************************************************* 
def random_elts(element_id_start: np.int32 = 0, 
                size: np.int32 = 64, 
                random_seed: np.int32 = 42,
                dtype = dtype):
    """
    Generate a DataFrame of random orbital elements
    INPUTS:
        element_id_start: First element_id used to label these elements
        size:             Number of elements to draw
        random_seed:      Random seed for the elements
        dtype:            Data type for the DataFrame.
    OUTPUTS:
        elts:        DataFrame of random orbital elemnents.
                     Columns include element_id, a, e, inc, Omega, omega, f, epoch.
                     Also includes h and R for mixture model.
    """
    # Set random state
    np.random.seed(random_seed)

    # Randomly sample a, e, inc, Omega from empirical observations
    a = np.random.choice(ast_elt.a, size=size)
    e = np.random.choice(ast_elt.e, size=size)
    inc = np.random.choice(ast_elt.inc, size=size)
    Omega = np.random.choice(ast_elt.Omega, size=size)

    # Sample mean anomaly M and omega randomly
    two_pi = 2.0*np.pi
    M = np.random.uniform(low=0.0, high=two_pi, size=size)
    omega = np.random.uniform(low=0.0, high=two_pi, size=size)

    # Allocate array for the true anomaly f
    f = np.zeros(size)

    # The epoch
    epoch0 = ast_elt.epoch.values[0]

    # Epoch as a datetime
    epoch_dt = mjd_to_datetime(epoch0)

    # Base Rebound simulation of the planets and moons on this date
    sim = make_sim_planets(epoch_dt=epoch_dt)
    # Set the number of active particles to the base simulation
    sim.N_active = sim.N

    # Iterate over candidate elements
    for i in range(size):
            # Set the primary to the sun (NOT the solar system barycenter!)
            # Put this inside the loop b/c not guaranteed to remain constant as particles are added
            primary = sim.particles['Sun']
            # Add the new asteroid
            sim.add(m=0.0, a=a[i], e=e[i], inc=inc[i], Omega=Omega[i], omega=omega[i], M=M[i], primary=primary)
            # The asteroid that was just added
            ast = sim.particles[-1]
            # Extract the true anomaly f
            f[i] = ast.f
            # Set the hash to the asteroid's number in this batch
            ast.hash = rebound.hash(f'{i}')

    # The element_id and epoch arrays
    element_id = np.arange(element_id_start, element_id_start+size, dtype=np.int32)
    epoch = np.full(shape=size, fill_value=epoch0)

    # Elements as a Python dict with required columns in order
    elts_dict = {
        'element_id': element_id,
        'a': a.astype(dtype),
        'e': e.astype(dtype),
        'f': f.astype(dtype),
        'inc': inc.astype(dtype),
        'Omega': Omega.astype(dtype),
        'omega': omega.astype(dtype),
        'epoch': epoch.astype(dtype)
    }

    # Convert these arrays to a DataFrame
    elts = pd.DataFrame(elts_dict)

    return elts

# ********************************************************************************************************************* 
# Augment candidate orbital elements with mixture model parameters
# ********************************************************************************************************************* 

# ********************************************************************************************************************* 
def elts_add_num_hits(elts: pd.DataFrame, num_hits: int = 10):
    """
    Populate the hit rate h by guessing each element has num_hits hits
    INPUTS:
        elts: DataFrame with columns a, e, inc, Omega, omega, f, epoch
        num_hits:     Number of hits to assume for computing the initial guess on hit rate h
    OUTPUTS:
        Modifies elts in place
    """
    # Update or add column num_hits
    elts['num_hits'] = num_hits

# # ********************************************************************************************************************* 
# def elts_add_hit_rate(elts: pd.DataFrame, score_by_elt: pd.DataFrame, num_hits: int = 10):
#     """
#     Populate the hit rate h by guessing each element has num_hits hits
#     INPUTS:
#         elts: DataFrame with columns a, e, inc, Omega, omega, f, epoch
#         score_by_elt: DataFrame generated by ztf_score_by_element in ztf_element.py
#         num_hits:     Number of hits to assume for computing the initial guess on hit rate h
#     OUTPUTS:
#         Modifies elts in place
#     """
#     # Filter down to the intersection
#     is_match = elts.element_id.isin(score_by_elt.index)
#     # elts = elts[is_match]
#     idx_missing = elts.index[~is_match]
#     elts.drop(idx_missing, inplace=True)
    
#     # Update column h
#     elts['h'] = num_hits / score_by_elt.num_obs.values

# ********************************************************************************************************************* 
def elts_add_R_deg(elts: pd.DataFrame, R_deg: float, dtype=dtype):
    """
    Add column to a DataFrame of orbital elements for the mixture parameter R.
    INPUTS:
        elts: DataFrame with columns a, e, inc, Omega, omega, f, epoch
        R:    Resolution parameter (Cartesian distance)
    OUTPUTS:
        Modifies elts in place
    """
    # Number of asteroids in this batch
    N_ast = elts.shape[0]

    # Convert R from degrees to Cartesian
    R = deg2dist(R_deg)

    # Add column for R
    elts['R'] = np.full(fill_value=R, shape=N_ast, dtype=dtype)

# ********************************************************************************************************************* 
def elts_add_thresh_deg(elts: pd.DataFrame, thresh_deg: float, dtype=dtype):
    """
    Add column to a DataFrame of orbital elements for the mixture parameter thresh_s.
    INPUTS:
        elts:     DataFrame with columns a, e, inc, Omega, omega, f, epoch
        thresh_s: threshold parameter (Cartesian distance)
    OUTPUTS:
        Modifies elts in place
    """
    # Number of asteroids in this batch
    N_ast = elts.shape[0]

    # Convert R from degrees to Cartesian
    thresh_s = deg2dist(thresh_deg)

    # Add column for R
    elts['thresh_s'] = np.full(fill_value=thresh_s, shape=N_ast, dtype=dtype)

# ********************************************************************************************************************* 
def elts_add_H(elts: pd.DataFrame, H: float=16.5, dtype=dtype):
    """
    Add column to a DataFrame of orbital elements for the brightness (magnitude) parameter H
    INPUTS:
        elts:   DataFrame with columns a, e, inc, Omega, omega, f, epoch
        H:      Brightness parameter; default of 16.5 by trial and error on 64 most common asteroids
                Mean of JPL data is 13.68, but ZTF apparent magnitudes are dimmer than model by about 2.5-3.0 range.
    OUTPUTS:
        Modifies elts in place
    """
    # Number of asteroids in this batch
    N_ast = elts.shape[0]

    # Add column for H
    elts['H'] = np.full(fill_value=H, shape=N_ast, dtype=dtype)
    
# ********************************************************************************************************************* 
def elts_add_mixture_params(elts: pd.DataFrame, 
                            num_hits: int, 
                            R_deg: float, 
                            thresh_deg: float,
                            dtype=dtype):
    """
    Add two columns to a DataFrame of orbital elements for the mixture parameters h and R.
    INPUTS:
        elts: DataFrame with columns a, e, inc, Omega, omega, f, epoch
        score_by_elt: DataFrame generated by ztf_score_by_element in ztf_element.py
        num_hits:     Number of hits to assume for computing the initial guess on hit rate h
        R_deg:        Resolution parameter in degrees
        thresh_deg:   Threshold parameter in degrees
        H:            Brightness parameter
        dtype:        Data type of DataFrame built
    OUTPUTS:
        Modifies elts in place
    """
    # Add columns for h, R and thresh
    elts_add_num_hits(elts=elts, num_hits=num_hits)
    elts_add_R_deg(elts=elts, R_deg=R_deg)
    elts_add_thresh_deg(elts=elts, thresh_deg=thresh_deg)
